/*
 * Environmental Monitoring Robot - Navigation Controller (Arduino Mega 2560)
 * 
 * MULTI-PROTOCOL WIRELESS SUPPORT
 * Select wireless protocol in globals.h:
 *   - WIRELESS_PROTOCOL_ZIGBEE: XBee modules (long range, reliable)
 *   - WIRELESS_PROTOCOL_LORA: LoRa modules (very long range, low power)
 *   - WIRELESS_PROTOCOL_BLE: Bluetooth (mobile device control)
 *
 * Responsibilities:
 *  - Waypoint navigation using GPS + compass
 *  - Obstacle avoidance via HC-SR04 on servo
 *  - Dual control: autonomous (from Raspberry Pi via I2C) or manual (wireless)
 *  - I2C slave interface for Raspberry Pi master (address 0x08)
 *  - Multi-protocol wireless fail-safe manual override channel
 *  - Buzzer feedback for communication status
 */

#include <Arduino.h>
#include <Wire.h>
#include <string.h>
#include <SPI.h>

#include "gps_handler.h"
#include "compass_handler.h"
#include "navigation.h"
#include "motor_control.h"
#include "obstacle_avoidance.h"
#include "globals.h"

// Select wireless implementation based on globals.h configuration
#ifdef WIRELESS_PROTOCOL_ZIGBEE
  #include "zigbee_driver.h"
  ZigBeeDriver wireless;
#elif defined(WIRELESS_PROTOCOL_LORA)
  #include "lora_driver.h"
  LoRaDriver wireless(LORA_CS_PIN, LORA_RST_PIN);
#elif defined(WIRELESS_PROTOCOL_BLE)
  #include "bluetooth_driver.h"
  BluetoothDriver wireless;
#else
  #error "No wireless protocol selected! Edit globals.h and uncomment WIRELESS_PROTOCOL_ZIGBEE, WIRELESS_PROTOCOL_LORA, or WIRELESS_PROTOCOL_BLE"
#endif

// Include base interface for type checking
#include "wireless_interface.h"

// ------------------------------- Components ----------------------------------
GPSHandler gps;
CompassHandler compass;
Navigation navigation;
MotorControl motors;
ObstacleAvoidance obstacleAvoid;

// ------------------------------- State ---------------------------------------
uint8_t responseBuffer[32];
uint8_t responseLength = 0;

PendingWaypoint pendingWaypoints[20];  // Adjust size as needed
uint8_t pendingWaypointCount = 0;

bool navigationActive = false;
bool manualOverride = false;
bool i2cHandshakeComplete = false;
bool wirelessHandshakeComplete = false;

unsigned long lastStatusUpdate = 0;
unsigned long lastWirelessGps = 0;
unsigned long lastManualCommand = 0;
unsigned long lastHeartbeat = 0;
unsigned long lastWirelessUpdate = 0;

int manualSpeed = 180;
String wirelessBuffer;
ControlMode controlMode = MODE_AUTO;

// Wireless compatibility: map old zigbee names to wireless
#define zigbeeHandshakeComplete wirelessHandshakeComplete
#define lastZigbeeGps lastWirelessGps

// For backward compatibility with functions still named "Zigbee"
String zigbeeBuffer;

// ========================== FORWARD DECLARATIONS ============================
void onI2CReceive(int bytes);
void onI2CRequest();
void handleI2CCommand(uint8_t command, const uint8_t* payload, uint8_t length);
void prepareAck(uint8_t code = 0);
void prepareError(uint8_t code);
void prepareGpsResponse();
void prepareStatusResponse();
void resetPendingWaypoints();
void storePendingWaypoint(const WaypointPacket& packet);
void commitPendingWaypoints();

void enterManualMode();
void exitManualMode(bool resumeAutonomous);
void processManualTimeout();

void handleWireless();
void processWirelessMessage(const String& message);
void sendWirelessGps();
void sendWirelessStatus();
void sendWirelessReady();
void sendWirelessObstacleAlert(int distance);

void beepPattern(uint8_t pulses, uint16_t onMs, uint16_t offMs);
void markI2CHandshake();
void markWirelessHandshake();
void checkReadyTone();

uint8_t readBatteryPercent();
uint8_t readSignalQuality();

// ========================== LEGACY FUNCTION WRAPPERS ========================
// For backward compatibility, maintain old function names that call new ones
void handleZigbee() { handleWireless(); }
void processZigbeeMessage(const String& message) { processWirelessMessage(message); }
void sendZigbeeGps() { sendWirelessGps(); }
void sendZigbeeStatus() { sendWirelessStatus(); }
void sendZigbeeReady() { sendWirelessReady(); }
void markZigbeeHandshake() { markWirelessHandshake(); }

// ========================== SETUP ==========================================
void setup() {
  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);

  DEBUG_SERIAL.begin(DEBUG_BAUD);
  while (!DEBUG_SERIAL) {
    delay(5);
  }

  DEBUG_SERIAL.println(F("\n# ========== ARDUINO MEGA NAVIGATION CONTROLLER =========="));
  DEBUG_SERIAL.println(F("# Booting subsystems..."));
  
  // Display selected wireless protocol
  #ifdef WIRELESS_PROTOCOL_ZIGBEE
    DEBUG_SERIAL.println(F("# Wireless: ZigBee (XBee) on Serial2 @ 57600 baud"));
  #elif defined(WIRELESS_PROTOCOL_LORA)
    DEBUG_SERIAL.println(F("# Wireless: LoRa (SX1276/RFM95W) on SPI"));
  #elif defined(WIRELESS_PROTOCOL_BLE)
    DEBUG_SERIAL.println(F("# Wireless: Bluetooth on Serial3 @ 38400 baud"));
  #endif

  GPS_SERIAL.begin(GPS_BAUD);

  Wire.begin(I2C_ADDRESS);
  Wire.onReceive(onI2CReceive);
  Wire.onRequest(onI2CRequest);

  if (gps.begin(GPS_SERIAL)) {
    DEBUG_SERIAL.println(F("# GPS initialized"));
  } else {
    DEBUG_SERIAL.println(F("# WARNING: GPS init failed - will use manual control only"));
    beepPattern(3, 200, 100);  // Triple beep warning
  }

  if (compass.begin()) {
    DEBUG_SERIAL.println(F("# Compass initialized"));
  } else {
    DEBUG_SERIAL.println(F("# WARNING: Compass init failed - navigation accuracy reduced"));
    beepPattern(3, 200, 100);  // Triple beep warning
  }

  motors.begin();
  obstacleAvoid.begin();
  navigation.begin(&gps, &compass, &motors, &obstacleAvoid);
  
  // Initialize wireless module
  if (wireless.begin()) {
    DEBUG_SERIAL.print(F("# Wireless initialized: "));
    DEBUG_SERIAL.println(wireless.getProtocolName());
  } else {
    DEBUG_SERIAL.println(F("# WARNING: Wireless init failed - I2C manual control only"));
    beepPattern(3, 200, 100);
  }
  
  DEBUG_SERIAL.println(F("# Note: System continues with any component failures - graceful degradation enabled"));
  DEBUG_SERIAL.println(F("# Awaiting I2C and wireless handshakes..."));
}

// ========================== MAIN LOOP ======================================
void loop() {
  gps.update();
  compass.update();
  obstacleAvoid.update();
  wireless.update();

  if (!manualOverride && navigationActive) {
    // Check GPS validity before navigation
    if (gps.isValid()) {
      navigation.update();

      if (navigation.isComplete()) {
        navigationActive = false;
        motors.stop();
        DEBUG_SERIAL.println(F("# All waypoints completed"));
        sendWirelessStatus();
      }
    } else {
      // No GPS fix - stop and wait
      static unsigned long lastGpsWarning = 0;
      if (millis() - lastGpsWarning > 5000) {
        DEBUG_SERIAL.println(F("# WARNING: Navigation paused - waiting for GPS fix"));
        sendWirelessStatus();
        motors.stop();
        lastGpsWarning = millis();
      }
    }
  }

  handleWireless();
  processManualTimeout();

  // Alert operator of obstacles in manual mode
  if (manualOverride && obstacleAvoid.isObstacleDetected()) {
    static unsigned long lastObstacleAlert = 0;
    if (millis() - lastObstacleAlert > 1000) {  // Alert every 1 second
      int distance = obstacleAvoid.getDistance();
      sendWirelessObstacleAlert(distance);
      
      DEBUG_SERIAL.print(F("# Manual mode obstacle alert: "));
      DEBUG_SERIAL.print(distance);
      DEBUG_SERIAL.println(F("cm"));
      
      lastObstacleAlert = millis();
      beepPattern(2, 100, 100);  // Double beep warning
    }
  }

  if (wirelessHandshakeComplete && (millis() - lastWirelessGps >= ZIGBEE_GPS_INTERVAL)) {
    sendWirelessGps();
    lastWirelessGps = millis();
  }

  if (millis() - lastStatusUpdate >= STATUS_INTERVAL) {
    lastStatusUpdate = millis();
    DEBUG_SERIAL.print(F("# Status -> mode:"));
    DEBUG_SERIAL.print(controlMode == MODE_AUTO ? F("AUTO") : F("MANUAL"));
    DEBUG_SERIAL.print(F(" nav:"));
    DEBUG_SERIAL.print(navigationActive ? F("RUN") : (navigation.isComplete() ? F("DONE") : F("IDLE")));
    DEBUG_SERIAL.print(F(" waypoints:"));
    DEBUG_SERIAL.print(navigation.getWaypointCount());
    DEBUG_SERIAL.print(F(" wireless:"));
    DEBUG_SERIAL.println(wireless.isConnected() ? F("OK") : F("OFFLINE"));
  }

  if (manualOverride && (millis() - lastManualCommand > MANUAL_TIMEOUT)) {
    exitManualMode(true);
  }

  if (navigationActive && (millis() - lastHeartbeat > HEARTBEAT_TIMEOUT)) {
    DEBUG_SERIAL.println(F("# Warning: heartbeat timeout"));
  }
}

// ========================== I2C HANDLING ===================================
void onI2CReceive(int bytes) {
  if (bytes <= 0) {
    return;
  }

  uint8_t command = Wire.read();
  uint8_t length = bytes - 1;
  uint8_t payload[32];

  for (int i = 0; i < length && i < 32; i++) {
    if (Wire.available()) {
      payload[i] = Wire.read();
    }
  }

  handleI2CCommand(command, payload, length);
}

void onI2CRequest() {
  Wire.write(responseBuffer, responseLength);
}

void handleI2CCommand(uint8_t command, const uint8_t* payload, uint8_t length) {
  switch (command) {
    case CMD_PING:
      markI2CHandshake();
      prepareAck();
      break;

    case CMD_NAV_START:
      if (navigation.getWaypointCount() > 0) {
        navigationActive = true;
        navigation.start();
        manualOverride = false;
        controlMode = MODE_AUTO;
        prepareAck();
        sendWirelessStatus();
      } else {
        prepareError(ERR_NO_WAYPOINTS);
      }
      break;

    case CMD_NAV_PAUSE:
      navigation.pause();
      navigationActive = false;
      motors.stop();
      prepareAck();
      break;

    case CMD_NAV_RESUME:
      if (navigation.getWaypointCount() > 0 && !navigation.isComplete()) {
        navigation.resume();
        navigationActive = true;
        manualOverride = false;
        controlMode = MODE_AUTO;
        prepareAck();
        sendWirelessStatus();
      } else {
        prepareError(ERR_NO_WAYPOINTS);
      }
      break;

    case CMD_WAYPOINT_CLEAR:
      navigation.clearWaypoints();
      resetPendingWaypoints();
      navigationActive = false;
      manualOverride = false;
      motors.stop();
      prepareAck();
      sendWirelessStatus();
      break;

    case CMD_WAYPOINT_PACKET:
      if (length >= sizeof(WaypointPacket)) {
        WaypointPacket packet;
        memcpy(&packet, payload, sizeof(WaypointPacket));
        storePendingWaypoint(packet);
        prepareAck();
      } else {
        prepareError(ERR_PACKET_SIZE);
      }
      break;

    case CMD_WAYPOINT_COMMIT:
      commitPendingWaypoints();
      prepareAck();
      sendWirelessStatus();
      break;

    case CMD_NAV_STOP:
      navigation.stop();
      navigationActive = false;
      manualOverride = false;
      motors.stop();
      controlMode = MODE_AUTO;
      prepareAck();
      sendWirelessStatus();
      break;

    case CMD_REQUEST_GPS:
      prepareGpsResponse();
      break;

    case CMD_REQUEST_STATUS:
      prepareStatusResponse();
      break;

    case CMD_HEARTBEAT:
      lastHeartbeat = millis();
      prepareAck();
      break;

    default:
      prepareError(0xFE);
      break;
  }
}

void prepareAck(uint8_t code) {
  responseBuffer[0] = RESP_ACK;
  responseBuffer[1] = code;
  responseLength = 2;
}

void prepareError(uint8_t code) {
  responseBuffer[0] = RESP_ERROR;
  responseBuffer[1] = code;
  responseLength = 2;
}

void prepareGpsResponse() {
  responseBuffer[0] = RESP_GPS;
  if (!gps.isValid()) {
    responseBuffer[1] = 0;
    responseLength = 2;
    return;
  }

  responseBuffer[1] = 1;
  float latitude = gps.getLatitude();
  float longitude = gps.getLongitude();
  float speed = gps.getSpeed();
  float heading = compass.getHeading();
  uint8_t satellites = gps.getSatellites();

  memcpy(&responseBuffer[2], &latitude, sizeof(float));
  memcpy(&responseBuffer[6], &longitude, sizeof(float));
  memcpy(&responseBuffer[10], &speed, sizeof(float));
  memcpy(&responseBuffer[14], &heading, sizeof(float));
  responseBuffer[18] = satellites;
  responseLength = 19;
}

void prepareStatusResponse() {
  responseBuffer[0] = RESP_STATUS;
  responseBuffer[1] = (controlMode == MODE_AUTO) ? 0 : 1;
  responseBuffer[2] = navigationActive ? 1 : 0;
  responseBuffer[3] = manualOverride ? 1 : 0;
  responseBuffer[4] = navigation.getWaypointCount();
  responseBuffer[5] = readBatteryPercent();
  responseBuffer[6] = readSignalQuality();
  responseLength = 7;
}

// ========================== WAYPOINT HANDLING ==============================
void resetPendingWaypoints() {
  pendingWaypointCount = 0;
}

void storePendingWaypoint(const WaypointPacket& packet) {
  if (pendingWaypointCount >= 20) {
    return;
  }

  PendingWaypoint slot;
  slot.latitude = packet.latitude;
  slot.longitude = packet.longitude;
  slot.id = packet.id;
  slot.seq = packet.seq;

  if (pendingWaypointCount == 0) {
    DEBUG_SERIAL.println(F("# Waypoint buffer: storing"));
  }

  pendingWaypoints[pendingWaypointCount++] = slot;
}

void commitPendingWaypoints() {
  navigation.clearWaypoints();
  for (uint8_t i = 0; i < pendingWaypointCount; ++i) {
    navigation.addWaypoint(pendingWaypoints[i].latitude, pendingWaypoints[i].longitude, pendingWaypoints[i].id);
  }

  DEBUG_SERIAL.print(F("# Waypoint committed: "));
  DEBUG_SERIAL.println(navigation.getWaypointCount());
  resetPendingWaypoints();
}

// ========================== WIRELESS HANDLING ==============================
void handleWireless() {
  WirelessMessage msg;
  
  while (wireless.receive(msg)) {
    if (msg.type == MSG_TYPE_COMMAND) {
      // Parse command (simple text-based for now)
      char cmdStr[65];
      memcpy(cmdStr, msg.data, msg.length);
      cmdStr[msg.length] = '\0';
      processWirelessMessage(String(cmdStr));
    }
  }
}

void processWirelessMessage(const String& message) {
  if (message.length() == 0) {
    return;
  }

  String command = message;
  command.toUpperCase();

  lastManualCommand = millis();

  if (command.startsWith("MCTL,FORWARD")) {
    enterManualMode();
    int speed = 200;
    int commaPos = command.indexOf(',', 5);
    if (commaPos > 0) {
      speed = command.substring(commaPos + 1).toInt();
    }
    motors.forward(speed);
    DEBUG_SERIAL.print(F("# Manual forward: "));
    DEBUG_SERIAL.println(speed);
  } 
  else if (command.startsWith("MCTL,BACKWARD")) {
    enterManualMode();
    int speed = 150;
    int commaPos = command.indexOf(',', 5);
    if (commaPos > 0) {
      speed = command.substring(commaPos + 1).toInt();
    }
    motors.backward(speed);
    DEBUG_SERIAL.print(F("# Manual backward: "));
    DEBUG_SERIAL.println(speed);
  } 
  else if (command.startsWith("MCTL,LEFT")) {
    enterManualMode();
    int speed = 180;
    int commaPos = command.indexOf(',', 5);
    if (commaPos > 0) {
      speed = command.substring(commaPos + 1).toInt();
    }
    motors.turnLeft(speed);
    DEBUG_SERIAL.print(F("# Manual left: "));
    DEBUG_SERIAL.println(speed);
  } 
  else if (command.startsWith("MCTL,RIGHT")) {
    enterManualMode();
    int speed = 180;
    int commaPos = command.indexOf(',', 5);
    if (commaPos > 0) {
      speed = command.substring(commaPos + 1).toInt();
    }
    motors.turnRight(speed);
    DEBUG_SERIAL.print(F("# Manual right: "));
    DEBUG_SERIAL.println(speed);
  } 
  else if (command.startsWith("MCTL,STOP")) {
    motors.stop();
    DEBUG_SERIAL.println(F("# Manual stop"));
  } 
  else if (command.startsWith("MCTL,MANUAL")) {
    enterManualMode();
    DEBUG_SERIAL.println(F("# Entering manual mode"));
  } 
  else if (command == "AUTO" || command == "RELEASE") {
    exitManualMode(true);
    DEBUG_SERIAL.println(F("# Exiting manual mode"));
  }
}

void sendWirelessGps() {
  if (!wireless.isConnected()) {
    return;
  }

  WirelessMessage msg;
  msg.type = MSG_TYPE_GPS;

  if (!gps.isValid()) {
    msg.length = 1;
    msg.data[0] = 0;  // Invalid flag
  } else {
    // Format: [valid:1][lat:4][lon:4][speed:4][heading:4][sats:1]
    msg.data[0] = 1;  // Valid flag
    float lat = gps.getLatitude();
    float lon = gps.getLongitude();
    float speed = gps.getSpeed();
    float heading = compass.getHeading();
    
    memcpy(&msg.data[1], &lat, 4);
    memcpy(&msg.data[5], &lon, 4);
    memcpy(&msg.data[9], &speed, 4);
    memcpy(&msg.data[13], &heading, 4);
    msg.data[17] = gps.getSatellites();
    msg.length = 18;
  }

  wireless.send(msg);
}

void sendWirelessStatus() {
  if (!wireless.isConnected()) {
    return;
  }

  WirelessMessage msg;
  msg.type = MSG_TYPE_STATUS;
  msg.data[0] = (controlMode == MODE_AUTO) ? 0 : 1;
  msg.data[1] = navigationActive ? 1 : 0;
  msg.data[2] = manualOverride ? 1 : 0;
  msg.data[3] = navigation.getWaypointCount();
  msg.data[4] = readBatteryPercent();
  msg.data[5] = wireless.getRSSI() & 0xFF;
  msg.length = 6;

  wireless.send(msg);
}

void sendWirelessReady() {
  if (!wireless.isConnected()) {
    return;
  }

  WirelessMessage msg;
  msg.type = MSG_TYPE_HANDSHAKE;
  msg.length = 0;
  wireless.send(msg);
  
  markWirelessHandshake();
}

void sendWirelessObstacleAlert(int distance) {
  if (!wireless.isConnected()) {
    return;
  }

  WirelessMessage msg;
  msg.type = MSG_TYPE_OBSTACLE;
  msg.data[0] = (distance >> 8) & 0xFF;
  msg.data[1] = distance & 0xFF;
  msg.data[2] = 0;  // Direction: 0=FRONT, 1=LEFT, 2=RIGHT
  msg.length = 3;

  wireless.send(msg);
}

// ========================== MANUAL MODE HANDLING ============================
void enterManualMode() {
  if (!manualOverride) {
    manualOverride = true;
    navigationActive = false;
    controlMode = MODE_MANUAL;
    motors.stop();
    DEBUG_SERIAL.println(F("# Manual mode entered"));
    beepPattern(1, 200, 0);
  }
}

void exitManualMode(bool resumeAutonomous) {
  if (manualOverride) {
    manualOverride = false;
    motors.stop();
    controlMode = resumeAutonomous ? MODE_AUTO : MODE_AUTO;
    DEBUG_SERIAL.println(F("# Manual mode exited"));
    
    if (resumeAutonomous && navigation.getWaypointCount() > 0 && !navigation.isComplete()) {
      navigationActive = true;
      navigation.resume();
      DEBUG_SERIAL.println(F("# Resuming autonomous navigation"));
    }
  }
}

void processManualTimeout() {
  if (!manualOverride) {
    return;
  }

  if (millis() - lastManualCommand > MANUAL_TIMEOUT) {
    exitManualMode(true);
  }
}

// ========================== HANDSHAKE & STATUS =============================
void markI2CHandshake() {
  i2cHandshakeComplete = true;
  DEBUG_SERIAL.println(F("# I2C handshake complete"));
  beepPattern(2, 100, 100);
}

void markWirelessHandshake() {
  wirelessHandshakeComplete = true;
  DEBUG_SERIAL.print(F("# Wireless handshake complete: "));
  DEBUG_SERIAL.println(wireless.getProtocolName());
  beepPattern(2, 100, 100);
}

void checkReadyTone() {
  if (i2cHandshakeComplete && wirelessHandshakeComplete) {
    beepPattern(4, 100, 100);
  }
}

// ========================== UTILITY FUNCTIONS ===============================
uint8_t readBatteryPercent() {
  // Placeholder: would read actual battery level from ADC
  return 85;
}

uint8_t readSignalQuality() {
  // Return RSSI if available from wireless module
  int8_t rssi = wireless.getRSSI();
  if (rssi == 0) return 0;
  // Convert RSSI to 0-100 quality
  // Typical range: -30 (excellent) to -100 (poor)
  if (rssi > -50) return 100;
  if (rssi < -90) return 10;
  return (rssi + 100) * 2;
}

void beepPattern(uint8_t pulses, uint16_t onMs, uint16_t offMs) {
  for (uint8_t i = 0; i < pulses; i++) {
    digitalWrite(BUZZER_PIN, HIGH);
    delay(onMs);
    digitalWrite(BUZZER_PIN, LOW);
    if (i < pulses - 1) {
      delay(offMs);
    }
  }
}
